---------- Petch Server im manuell mit iex ausfÃ¼hren
Servy.PledgeServer.start()
pid2 = Process.whereis(:pledge_server)
Process.alive?(pid2)
Process.unregister(:pledge_server)
Process.whereis(:pledge_server)

pid = self()
Process.register(pid, :pledgy)
Process.whereis(:pledgy)

pid = Servy.PledgeServer.start()
1..500 |> Enum.each(fn(n) -> send pid, {:stop, "hammertime #{n}"} end)
for n <- 501..1000, do: send pid, {:stop, "hammertime #{n}"}
Process.info(pid, :message_queue_len)
:observer.start


---------- Kombiniere PetchServer mit HttpServer
im 1. Fenster mit iex
Servy.FourOhFourCounter.start()
Servy.PledgeServer.start([{"larry", 10}])
Servy.PledgeServer.recent_pledges
Servy.HttpServer.start(4000)

im 2. Fenster mit bash
curl -X POST http:/localhost:4000/pledges -d 'name=larry&amount=100'
curl -X POST http://localhost:4000/pledges -d 'name=moe&amount=200'
curl -X POST http://localhost:4000/pledges -d 'name=curly&amount=300'
curl -X POST http://localhost:4000/pledges -d 'name=daisy&amount=500'
curl http://localhost:4000/pledges


---------- Using Agent
It is a quick and easy way to store state in a process.  Agent is great if you simply need a process to store state. 
But it can't also run asynchronous queries or computations in the server proces.
Sometimes you need a server to store state and do other things related to that state.

{:ok, agent} = Agent.start(fn -> [] end)
Agent.update(agent, fn(state) -> [ {"larry", 10} | state ] end)
Agent.update(agent, fn(state) -> [ {"moe", 20} | state ] end)
Agent.get(agent, fn(state) -> state end)


---------- HTTPoison
url = "https://httparrot.herokuapp.com/post"
body = ~s({"name": "larry", "amount": 10})
{:ok, response} = HTTPoison.post url, body
Poison.Parser.parse!(response.body, %{})

headers = [{"Content-Type", "application/json"}]
{:ok, response} = HTTPoison.post url, body, headers


